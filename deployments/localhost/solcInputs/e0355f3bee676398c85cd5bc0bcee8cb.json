{
  "language": "Solidity",
  "sources": {
    "@interep/contracts/IInterep.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title Interep interface.\n/// @dev Interface of a Interep contract.\ninterface IInterep {\n    struct Verifier {\n        address contractAddress;\n        uint8 merkleTreeDepth;\n    }\n\n    struct Group {\n        bytes32 provider;\n        bytes32 name;\n        uint256 root;\n        uint8 depth;\n    }\n\n    /// @dev Emitted when a Semaphore proof is verified.\n    /// @param groupId: Id of the group.\n    /// @param signal: Semaphore signal.\n    event ProofVerified(uint256 indexed groupId, bytes32 signal);\n\n    /// @dev Emitted when an Interep group is updated.\n    /// @param groupId: Id of the group.\n    /// @param provider: Provider of the group.\n    /// @param name: Name of the group.\n    /// @param root: Root hash of the tree.\n    /// @param depth: Depth of the tree.\n    event GroupUpdated(\n        uint256 groupId,\n        bytes32 indexed provider,\n        bytes32 indexed name,\n        uint256 root,\n        uint8 indexed depth\n    );\n\n    /// @dev Updates the Interep groups.\n    /// @param groups: List of Interep groups.\n    function updateGroups(Group[] calldata groups) external;\n\n    /// @dev Saves the nullifier hash to avoid double signaling and emits an event\n    /// if the zero-knowledge proof is valid.\n    /// @param groupId: Id of the group.\n    /// @param signal: Semaphore signal.\n    /// @param nullifierHash: Nullifier hash.\n    /// @param externalNullifier: External nullifier.\n    /// @param proof: Zero-knowledge proof.\n    function verifyProof(\n        uint256 groupId,\n        bytes32 signal,\n        uint256 nullifierHash,\n        uint256 externalNullifier,\n        uint256[8] calldata proof\n    ) external;\n\n    /// @dev Returns the root hash of an Interep group.\n    /// @param groupId: Id of the group.\n    /// @return Root hash of the group.\n    function getRoot(uint256 groupId) external view returns (uint256);\n\n    /// @dev Returns the tree depth of an Interep group.\n    /// @param groupId: Id of the group.\n    /// @return Tree depth of the group.\n    function getDepth(uint256 groupId) external view returns (uint8);\n}\n"
    },
    "@semaphore-protocol/contracts/base/SemaphoreConstants.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nuint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n"
    },
    "@semaphore-protocol/contracts/base/SemaphoreCore.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ISemaphoreCore.sol\";\nimport \"../interfaces/IVerifier.sol\";\n\n/// @title Semaphore core contract.\n/// @notice Minimal code to allow users to signal their endorsement of an arbitrary string.\n/// @dev The following code verifies that the proof is correct and saves the hash of the\n/// nullifier to prevent double-signaling. External nullifier and Merkle trees (i.e. groups) must be\n/// managed externally.\ncontract SemaphoreCore is ISemaphoreCore {\n    /// @dev Gets a nullifier hash and returns true or false.\n    /// It is used to prevent double-signaling.\n    mapping(uint256 => bool) internal nullifierHashes;\n\n    /// @dev Asserts that no nullifier already exists and if the zero-knowledge proof is valid.\n    /// Otherwise it reverts.\n    /// @param signal: Semaphore signal.\n    /// @param root: Root of the Merkle tree.\n    /// @param nullifierHash: Nullifier hash.\n    /// @param externalNullifier: External nullifier.\n    /// @param proof: Zero-knowledge proof.\n    /// @param verifier: Verifier address.\n    function _verifyProof(\n        bytes32 signal,\n        uint256 root,\n        uint256 nullifierHash,\n        uint256 externalNullifier,\n        uint256[8] calldata proof,\n        IVerifier verifier\n    ) internal view {\n        require(!nullifierHashes[nullifierHash], \"SemaphoreCore: you cannot use the same nullifier twice\");\n\n        uint256 signalHash = _hashSignal(signal);\n\n        verifier.verifyProof(\n            [proof[0], proof[1]],\n            [[proof[2], proof[3]], [proof[4], proof[5]]],\n            [proof[6], proof[7]],\n            [root, nullifierHash, signalHash, externalNullifier]\n        );\n    }\n\n    /// @dev Stores the nullifier hash to prevent double-signaling.\n    /// Attention! Remember to call it when you verify a proof if you\n    /// need to prevent double-signaling.\n    /// @param nullifierHash: Semaphore nullifier hash.\n    function _saveNullifierHash(uint256 nullifierHash) internal {\n        nullifierHashes[nullifierHash] = true;\n    }\n\n    /// @dev Creates a keccak256 hash of the signal.\n    /// @param signal: Semaphore signal.\n    /// @return Hash of the signal.\n    function _hashSignal(bytes32 signal) private pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(signal))) >> 8;\n    }\n}\n"
    },
    "@semaphore-protocol/contracts/interfaces/ISemaphoreCore.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title SemaphoreCore interface.\n/// @dev Interface of SemaphoreCore contract.\ninterface ISemaphoreCore {\n    /// @notice Emitted when a proof is verified correctly and a new nullifier hash is added.\n    /// @param nullifierHash: Hash of external and identity nullifiers.\n    event NullifierHashAdded(uint256 nullifierHash);\n}\n"
    },
    "@semaphore-protocol/contracts/interfaces/IVerifier.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title Verifier interface.\n/// @dev Interface of Verifier contract.\ninterface IVerifier {\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[4] memory input\n    ) external view;\n}\n"
    },
    "contracts/InterepTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@interep/contracts/IInterep.sol\";\nimport \"@semaphore-protocol/contracts/interfaces/IVerifier.sol\";\nimport \"@semaphore-protocol/contracts/base/SemaphoreCore.sol\";\nimport \"@semaphore-protocol/contracts/base/SemaphoreConstants.sol\";\n\ncontract InterepTest is IInterep, SemaphoreCore {\n    /// @dev Gets a tree depth and returns its verifier address.\n    mapping(uint8 => IVerifier) public verifiers;\n\n    mapping(uint256 => Group) public groups;\n\n    /// @dev Checks if there is a verifier for the given tree depth.\n    /// @param depth: Depth of the tree.\n    modifier onlySupportedDepth(uint8 depth) {\n        require(\n            address(verifiers[depth]) != address(0),\n            \"Interep: tree depth is not supported\"\n        );\n        _;\n    }\n\n    /// @dev Initializes the Semaphore verifiers used to verify the user's ZK proofs.\n    /// @param _verifiers: List of Semaphore verifiers (address and related Merkle tree depth).\n    constructor(Verifier[] memory _verifiers) {\n        for (uint8 i = 0; i < _verifiers.length; i++) {\n            verifiers[_verifiers[i].merkleTreeDepth] = IVerifier(\n                _verifiers[i].contractAddress\n            );\n        }\n    }\n\n    /// @dev See {IInterep-updateGroups}.\n    function updateGroups(Group[] calldata _groups) external override {\n        for (uint8 i = 0; i < _groups.length; i++) {\n            uint256 groupId = uint256(\n                keccak256(\n                    abi.encodePacked(_groups[i].provider, _groups[i].name)\n                )\n            ) % SNARK_SCALAR_FIELD;\n\n            _updateGroup(groupId, _groups[i]);\n        }\n    }\n\n    /// @dev See {IInterep-getRoot}.\n    function getRoot(uint256 groupId) public view override returns (uint256) {\n        return groups[groupId].root;\n    }\n\n    /// @dev See {IInterep-getDepth}.\n    function getDepth(uint256 groupId) public view override returns (uint8) {\n        return groups[groupId].depth;\n    }\n\n    /// @dev Updates an Interep group.\n    /// @param groupId: Id of the group.\n    /// @param group: Group data.\n    function _updateGroup(uint256 groupId, Group calldata group) private {\n        groups[groupId] = group;\n\n        emit GroupUpdated(\n            groupId,\n            group.provider,\n            group.name,\n            group.root,\n            group.depth\n        );\n    }\n\n    /// @dev See {IInterep-verifyProof}.\n    function verifyProof(\n        uint256 groupId,\n        bytes32 signal,\n        uint256 nullifierHash,\n        uint256 externalNullifier,\n        uint256[8] calldata proof\n    ) external override {\n        uint256 root = getRoot(groupId);\n        uint8 depth = getDepth(groupId);\n\n        require(depth != 0, \"Interep: group does not exist\");\n\n        IVerifier verifier = verifiers[depth];\n\n        _verifyProof(\n            signal,\n            root,\n            nullifierHash,\n            externalNullifier,\n            proof,\n            verifier\n        );\n\n        // NOTE: After @interep/contracts is updated to use @semaphore-protocol/contracts v2,6.1, the logic to saveNullifierHash will change\n        // ref: https://github.com/semaphore-protocol/semaphore/blob/68779e90a0db120d9c36143c5f48ca6fd1a2a159/packages/contracts/contracts/interfaces/ISemaphore.sol#L23\n        // https://github.com/semaphore-protocol/semaphore/blob/68779e90a0db120d9c36143c5f48ca6fd1a2a159/packages/contracts/contracts/Semaphore.sol#L162-L171\n        // Till then, downgrading semaphore-protocol/contracts to v2.0.0\n        _saveNullifierHash(nullifierHash);\n\n        emit ProofVerified(groupId, signal);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
